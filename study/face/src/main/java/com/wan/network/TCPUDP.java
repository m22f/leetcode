package com.wan.network;
/**
 * 计算机网络： 
 * 应用层
 * 网络层
 * 接口层
 * 网际层
 * 物理层
 * 三次握手
 * 客户端向服务端发送syn报文 包含随机生成的序列号x                               此时客户端进入syn_sent状态 等待服务器报文，超时会重新发送syn报文，
 * 服务端接收到客户端请求，发送给客户端sys-ack报文，包括确认号x+1,和随机序列号y    此时服务端进入syn_rcvd状态 等待客户端报文，超时重新发送
 * 客户端收到服务端消息，发送给服务端ack报文，包含确认号y+1，和序列号x+1           客户端进入established
 * 服务端收到客户端消息                                                        服务端进入established
 * 
 * 超时时间与重试次数：超时时间基于网络的往返时延估计，采用指数退避，即时间指数增加，1，2，4，8，16，不同系统不同，可以自定义
 *                   对于服务器而言，syn_rcvd状态为半连接状态，也是ddos攻击的目标，因为，服务器会为处于syn_rcvd状态的连接分配一定资源
 * 
 * 传送过程中报文的丢失：
 *        前两次的发送由于有确认的对象，所以可以采用超时重发
 *        而第三次由客户端发出的ack消息丢失后，客户端会直接进入established状态，认为连接已经建立
 *        这种情况下：
 *            1.如果客户端立即向服务端发送消息，那么这个数据包本身也会携带ack标志位且确认号为y+1,此时服务端收到消息就会进入established状态
 *            2.如果客户端不立即向服务端发消息，那么服务端会进行超时重发syn-ack，而客户端知道连接已经建立，就会丢弃这个消息，并回复ack报文
 * 连接后的累计确认与重传：
 *      接收方对每个数据块发送确认消息包含确认码ack=n，意指接收方已经收到了n之前的所有数据，现在希望序列号为n的数据包
 *      若中途丢包，会使得发送方收到多个相同确认号，就会触发快速重传，立即发送接收方希望的包
 *      对于收到不连续的包，接收方会放入缓冲区，变得连续后，发送包含确认号为目前仍缺的数据包序号的ack报文
 *      使用累计确认，而非对每个包都发送回复
 * 
 * 四次挥手
 * 由于tcp是全双工通信，且两边对资源关闭大概率不同步，所以关闭时，要两边都分别发送fin报文和对fin报文进行确认
 * fin报文包含fin和ack标志位
 * 多路复用
 * select poll epoll
 * session cocicker
 */
public class TCPUDP {
    
}
